#include <iostream>
#include <random>
#include <vector>
#include <unordered_map>
#include "experiment.h"
#include "UnionFind.h"
#include "QU_NC.h"
#include "QU_FC.h"
#include "UR_FC.h"
#include "UR_NC.h"
#include "UW_FC.h"
#include "UW_NC.h"

using namespace std;

// QU: unweighted quick-union, (2) UW: union-by-size (a.k.a. union-by-weight), (3) UR: union-by-rank. The choices for path compression are: (1) NC: no compression, (2) FC: full path compression, (3) PS: path splitting, (4) PH: path halving.

// Define an enum for the types
enum UFType { QU_NC, QU_FC, UR_FC, UR_NC, UW_FC, UW_NC };

int main(int argc, char* argv[]) {
  // check if an argument is provided
  if (argc != 3) {
    cerr << "Usage: " << argv[0] << "<string argument>" << " <integer argument>" << endl;
    return 1; // return error code
  }
  // Convert the argument to an integer
  int n;
  try {
    n = stoi(argv[2]);
  }
  catch (const std::invalid_argument& e) {
    cerr << "Invalid argument: " << argv[2] << endl;
    return 1; // Return error code
  }
  // Define a mapping from string to UFType
  unordered_map<string, UFType> typeMap = {
      {"QU_NC", QU_NC},
      {"QU_FC", QU_FC},
      {"UR_FC", UR_FC},
      {"UR_NC", UR_NC},
      {"UW_FC", UW_FC},
      {"UW_NC", UW_NC}
  };

  // Get the type from command-line arguments
  string typeStr = argv[1];
  // Ensure that the input type is valid
  if (typeMap.find(typeStr) == typeMap.end()) {
    cerr << "Invalid value of type. It should be QU_NC || QU_FC || UR_FC || UR_NC || UW_FC || UW_NC." << endl;
    return 1; // Return error code
  }
  // Convert the string type to UFType
  UFType type = typeMap[typeStr];

  int delta = 1; //stoi(argv[2]);
  const int T = 20;
  const int min_executions = 5;
  int epsilon = 2; //Cost of updating a pointer

  UnionFind* uf;

  int total = n / delta + 1;
  vector<double> avg_tpl_values(total, 0);
  vector<double> avg_tpu_values(total, 0);
  vector<double> avg_cost_values(total, 0);
  vector<int> executions_count(total, 0);

  for (int t = 0; t < T; ++t) {
    int processed_pairs = 0;
    switch (type) {
    case QU_NC:
      uf = new QuickUnionNoCompression(n);
      break;
    case QU_FC:
      uf = new QuickUnionFullCompression(n);
      break;
    case UR_FC:
      uf = new UnionRankFullCompression(n);
      break;
    case UR_NC:
      uf = new UnionRankNoCompression(n);
      break;
    case UW_FC:
      uf = new UnionWeightFullCompression(n);
      break;
    case UW_NC:
      uf = new UnionWeightNoCompression(n);
      break;
    }

    // Generate distinct pairs of elements (i, j) in random order
    vector<pair<int, int>> pairs = generate_pairs(n);

    for (const auto& pair : pairs) {
      if (!uf->connected(pair.first, pair.second)) {
        uf->merge(pair.first, pair.second);
        processed_pairs++;
        // printUF(uf);
        if (processed_pairs % delta == 0 || processed_pairs == n) {
          int index = processed_pairs / delta;
          avg_tpl_values[index] += uf->tpl();
          avg_tpu_values[index] += uf->tpu();
          avg_cost_values[index] += uf->totalCost(epsilon);
          executions_count[index]++;
        }
      }
      if (uf->nr_blocks() == 1) {
        break;
      }
    }
    // printUF(uf);
  }
  delete uf;

  // data to be written to the CSV file
  std::vector<std::vector<std::string>> data;
  // Add header
  data.push_back({ "N", "Average TPL", "Average TPU", "Average Cost" });

  for (int i = 0; i < avg_tpl_values.size(); ++i) {
    if (executions_count[i] >= min_executions) {
      avg_tpl_values[i] /= executions_count[i];
      avg_tpu_values[i] /= executions_count[i];
      avg_cost_values[i] /= executions_count[i];
      data.push_back({ to_string(i * delta), to_string(avg_tpl_values[i]), to_string(avg_tpu_values[i]), to_string(avg_cost_values[i]) });
    }
  }

  // Name of the CSV file to be written
  string filename = "outputs/" + typeStr + "_" + to_string(n) + ".csv";

  // comments to be written to the CSV file
  std::vector<std::string> comments = {
      "This is a CSV file generated by my program.",
      "Comments can be added at the beginning of the file."
  };
  // Write data to the CSV file
  writeCSV(filename, data, comments);

  std::cout << "Data has been written to " << filename << std::endl;

  return 0;
}
